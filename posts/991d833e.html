<!DOCTYPE html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Liunx Futex | Juzzia's Blog</title><meta name=author content=Juzzia><meta name=copyright content=Juzzia><meta name=format-detection content="telephone=no"><meta name=theme-color content=ffffff><meta name=description content="背景 写这篇的文章的原因是因为在研究 java 的重量级锁中用到了 pthred_mutex_t作为互斥锁，pthred_mutex_t中加锁函数pthread_mutex_lock当竞争锁失败时便会通过系统调用futex_wait将当前线程阻塞等待到其内部的条件变量__lock上，设置线程的状态为INTERRUPTABLE，当使用解锁函数pthread_mutex_unlock时便会将__lo"><meta property=og:type content=article><meta property=og:title content="Liunx Futex"><meta property=og:url content=https://juzzia.github.io/posts/991d833e.html><meta property=og:site_name content="Juzzia&#39;s Blog"><meta property=og:description content="背景 写这篇的文章的原因是因为在研究 java 的重量级锁中用到了 pthred_mutex_t作为互斥锁，pthred_mutex_t中加锁函数pthread_mutex_lock当竞争锁失败时便会通过系统调用futex_wait将当前线程阻塞等待到其内部的条件变量__lock上，设置线程的状态为INTERRUPTABLE，当使用解锁函数pthread_mutex_unlock时便会将__lo"><meta property=og:locale content=zh_CN><meta property=og:image content=https://juzzia.github.io/img/avatar.jpg><meta property=article:published_time content=2025-02-22T15:33:00.000Z><meta property=article:modified_time content=2025-03-06T13:33:00.000Z><meta property=article:author content=Juzzia><meta name=twitter:card content=summary><meta name=twitter:image content=https://juzzia.github.io/img/avatar.jpg><link rel="shortcut icon" href=/img/log.svg><link rel=canonical href=https://juzzia.github.io/posts/991d833e.html><link rel=preconnect href=//cdn.jsdelivr.net><link rel=preconnect href=//hm.baidu.com><link rel=preconnect href=//busuanzi.ibruce.info><meta name=msvalidate.01 content=606EBFCBDED9F21417F108AFF320F465><link rel=stylesheet href="/css/index.css?v=4.13.0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?344a26e9d7e5894ce499ae53b475d975",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script><script>let GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:5,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"prismjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!0,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id=config-diff>var GLOBAL_CONFIG_SITE={title:"Liunx Futex",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-03-06 21:33:00"}</script><script>(e=>{e.saveToLocal={set:(e,t,a)=>{var o;0!==a&&(o=Date.now(),localStorage.setItem(e,JSON.stringify({value:t,expiry:o+864e5*a})))},get:e=>{var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!(Date.now()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=(o,n={})=>new Promise((t,e)=>{let a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},Object.keys(n).forEach(e=>{a.setAttribute(e,n[e])}),document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{let a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel=stylesheet href=/css/callout/callout_blocks.css><link rel=stylesheet href=/css/mermaid.css><link rel=stylesheet href=/css/custom.css><meta name=generator content="Hexo 7.3.0"></head><body><div id=web_bg></div><div id=sidebar><div id=menu-mask></div><div id=sidebar-menus><div class="avatar-img is-center"><img src=/img/avatar.jpg onerror='onerror=null,src="/img/friend_404.gif"' alt=avatar></div><div class="sidebar-site-data site-data is-center"><a href=/archives/ ><div class=headline>文章</div><div class=length-num>10</div></a><a href=/tags/ ><div class=headline>标签</div><div class=length-num>4</div></a><a href=/categories/ ><div class=headline>分类</div><div class=length-num>5</div></a></div><hr class=custom-hr><div class=menus_items><div class=menus_item><a class=site-page href=/ ><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class=menus_item><a class=site-page href=/archives/ ><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class=menus_item><a class=site-page href=/tags/ ><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class=menus_item><a class=site-page href=/categories/ ><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class=menus_item><a class=site-page href=/about/ ><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class=post id=body-wrap><header class=not-top-img id=page-header><nav id=nav><span id=blog-info><a href=/ title="Juzzia's Blog"><span class=site-name>Juzzia's Blog</span></a></span><div id=menus><div id=search-button><a class="site-page social-icon search" href=javascript:void(0);><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class=menus_items><div class=menus_item><a class=site-page href=/ ><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class=menus_item><a class=site-page href=/archives/ ><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class=menus_item><a class=site-page href=/tags/ ><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class=menus_item><a class=site-page href=/categories/ ><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class=menus_item><a class=site-page href=/about/ ><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id=toggle-menu><a class=site-page href=javascript:void(0);><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class=layout id=content-inner><div id=post><div id=post-info><h1 class=post-title>Liunx Futex</h1><div id=post-meta><div class=meta-firstline><span class=post-meta-date><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class=post-meta-label>发表于</span><time datetime=2025-02-22T15:33:00.000Z title="发表于 2025-02-22 23:33:00">2025-02-22</time></span><span class=post-meta-categories><span class=post-meta-separator>|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class=post-meta-categories href=/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ >源码分析</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class=post-meta-categories href=/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/liunx/ >liunx</a></span></div><div class=meta-secondline><span class=post-meta-separator>|</span><span class=post-meta-wordcount><i class="far fa-file-word fa-fw post-meta-icon"></i><span class=post-meta-label>字数总计:</span><span class=word-count>6.1k</span><span class=post-meta-separator>|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class=post-meta-label>阅读时长:</span><span>23分钟</span></span><span class=post-meta-separator>|</span><span class=post-meta-pv-cv id="" data-flag-title="Liunx Futex"><i class="far fa-eye fa-fw post-meta-icon"></i><span class=post-meta-label>阅读量:</span><span id=busuanzi_value_page_pv><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class=post-meta-separator>|</span><span class=post-meta-commentcount><i class="far fa-comments fa-fw post-meta-icon"></i><span class=post-meta-label>评论数:</span><a href=/posts/991d833e.html#post-comment><span class=gsc-comments-count><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><article class=post-content id=article-container><h2 id=背景><a class=markdownIt-Anchor href=#背景></a> 背景</h2><p>写这篇的文章的原因是因为在研究 java 的重量级锁中用到了 <code>pthred_mutex_t</code>作为互斥锁，<code>pthred_mutex_t</code>中加锁函数<code>pthread_mutex_lock</code>当竞争锁失败时便会通过系统调用<code>futex_wait</code>将当前线程阻塞等待到其内部的条件变量<code>__lock</code>上，设置线程的状态为<code>INTERRUPTABLE</code>，当使用解锁函数<code>pthread_mutex_unlock</code>时便会将<code>__lock</code>的值改变为0，然后通过系统调用<code>futex_wake</code>唤醒阻塞等待在条件变量<code>__lock</code>上的线程，将线程的状态改为可运行状态，当然，上面的流程是看完<code>futex</code>的源码后总结的一个大概的流程，为了搞清楚<code>pthread_mutex_lock</code>和<code>pthread_mutex_unlock</code>做了什么，我只能深究源码，解答心中疑惑</p><h2 id=锁><a class=markdownIt-Anchor href=#锁></a> 锁</h2><p>在介绍<code>futex</code>之前，我想先在java层面去介绍为什么不在用户态去实现自己的锁机制，这样就能够避免由于系统调用导致线程上下文切换的开销，因为我在深究源码的过程中也出现了类似的疑惑，搜寻了很多博客以及AI但是并未给出我想要的回答，当看懂了<code>futex</code>的源码后我才懂了为什么不这样做，接下来让我们先尝试在java层面设计一个自己的锁</p><h3 id=java-lock><a class=markdownIt-Anchor href=#java-lock></a> Java Lock</h3><p>我们可以想一下常见锁的机制</p><ul><li><code>lock</code>和<code>unlock</code>：如果加锁成功就返回，如果失败就要能够阻塞等待，不能一直自旋等待锁的释放，当持有锁的线程释放后就需要唤醒在锁上阻塞等待的线程去竞争锁</li><li><code>wait</code>和<code>notify</code>：当持有锁的线程执行过程中发现某个条件不满足时，就应该主动的放弃锁的持有权，并且由于线程是因为条件不满足释放锁的，所以当条件不满足之前都不应该拥有竞争锁的权力，直到条件满足时竞争到锁后再向下执行。当某个线程获得锁后，改变条件的状态后便需要将正在该条件上阻塞等待的线程提升为也能够正常参与竞争锁的状态</li></ul><p>根据上面的机制，因此就有了如下的简单实现</p><pre class="line-numbers language-java" data-language=java><code class=language-java><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Lock</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// 锁变量，0无锁 1有锁</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicBoolean</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 锁变量，0无锁 1有锁</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicBoolean</span> entryLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 锁变量，0无锁 1有锁</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicBoolean</span> waitLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 锁的持有者</span>
	<span class="token keyword">private</span> <span class="token class-name">Thread</span> owner<span class="token punctuation">;</span>
	<span class="token comment">// 重入次数</span>
	<span class="token keyword">private</span> <span class="token keyword">int</span> recurrences<span class="token punctuation">;</span>
	<span class="token comment">// 进入到该锁中竞争阻塞的线程队列</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">></span></span> entryList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 等待条件唤醒的等待队列</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">></span></span> waitList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	

	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>owner <span class="token operator">==</span> current<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				recurrences<span class="token operator">++</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				owner <span class="token operator">=</span> current<span class="token punctuation">;</span>
				<span class="token keyword">return</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token function">queueSpinLock</span><span class="token punctuation">(</span>entryLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
			entryList<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">queueUnlock</span><span class="token punctuation">(</span>entryLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">wait</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>owner <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>recurrences <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			recurrences<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		owner <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		lock<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 不满足时，应该阻塞等待</span>
		<span class="token function">queueSpinLock</span><span class="token punctuation">(</span>entryLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Thread</span> waitLockThread <span class="token operator">=</span> entryList<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">queueUnlock</span><span class="token punctuation">(</span>entryLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		entryLock<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>waitLockThread <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token function">wake</span><span class="token punctuation">(</span>waitLockThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// Object的wait方法不可重写</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">wait0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>owner <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>

		<span class="token function">queueSpinLock</span><span class="token punctuation">(</span>entryLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Thread</span> wokenThread <span class="token operator">=</span> entryList<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">queueUnlock</span><span class="token punctuation">(</span>entryLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">queueSpinLock</span><span class="token punctuation">(</span>waitLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		waitList<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">queueUnlock</span><span class="token punctuation">(</span>waitLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		owner <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		lock<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">wake</span><span class="token punctuation">(</span>wokenThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">wait</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token comment">// Object的notify方法不可重写</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notify0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>owner <span class="token operator">!=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">queueSpinLock</span><span class="token punctuation">(</span>waitLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Thread</span> wokenThread <span class="token operator">=</span> waitList<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">queueUnlock</span><span class="token punctuation">(</span>waitLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>wokenThread <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token function">queueSpinLock</span><span class="token punctuation">(</span>entryLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
			entryList<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>wokenThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">queueUnlock</span><span class="token punctuation">(</span>entryLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>


	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token comment">// 线程等待，这里的实现在java层面没有,也就是我本小节想讲的地方</span>
		<span class="token comment">// 通常使用 LockSupport.park(); 来将当前线程状态置为不可调度状态</span>
		<span class="token comment">// java层面是WAITING，os层面是INTERRUPTABLE</span>
		<span class="token comment">// LockSupport.park();</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">wake</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token comment">// 线程唤醒，这里的实现java层面没有</span>
		<span class="token comment">// 通常使用LockSupport.unpark(waitLockThread),将线程状态置为可运行状态</span>
		<span class="token comment">// java层面是RUNNABLE，os层面是RUNNING</span>
		<span class="token comment">// LockSupport.unpark(t);</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">queueSpinLock</span><span class="token punctuation">(</span><span class="token class-name">AtomicBoolean</span> lock<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				<span class="token keyword">return</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">queueUnlock</span><span class="token punctuation">(</span><span class="token class-name">AtomicBoolean</span> lock<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		lock<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码是一个简单的锁的实现，将<code>wait(Thread t)</code>和<code>wake(Thread t)</code>中分别使用的<code>LockSupport</code>工具类中的<code>park</code>和<code>unpark</code>方法的注释打开是能够正常工作的，但我这里却不想用该类中的方法，并且也在注释说明了原因，因为该方法底层会进行系统调用从而会导致线程上下文切换，本小节开头就说想在用户态实现线程之间的通信机制，避免系统调用的开销，让我们来想想在用户态怎么才能够做到</p><ul><li>要想当锁条件不满足时让出cpu的执行权但又避免系统调用的开销，那么用户态就必须能够调度线程的运行，这显然是不安全的，恶意进程可以永远只调度自己的线程，而导致其他线程饥饿，就这一点就足以否决这种优化效率的提案</li></ul><h2 id=介绍><a class=markdownIt-Anchor href=#介绍></a> 介绍</h2><p>在Liunx 内核中提供了一种快速检查锁冲突的系统调用，称为<code>Fast Userspace Mutex</code> 简称 <code>Futex</code>，它避免了当锁未冲突时也需要陷入到内核态完成加锁操作再切换到用户态的开销，只有当锁冲突时，竞争锁的线程才需要陷入内核态去阻塞等待锁的释放</p><p><code>futex</code>提供了两个关键的方法，从而支持了当用户态检测到锁冲突时可以阻塞竞争锁的线程，当锁被持有者释放了再唤醒阻塞等待的线程，这两个方法分别是：</p><ul><li><code>futex_wait(u32 __user *uaddr, unsigned int flags, u32 val, ktime_t *abs_time, u32 bitset)</code> <a target=_blank rel=noopener href=https://elixir.bootlin.com/linux/v4.0/source/kernel/futex.c#L2164>源码链接</a><ul><li><code>*uaddr</code>：指向用户空间锁变量地址的指针</li><li><code>flags</code>：锁标志位<ul><li><code>FLAGS_SHARED = 0x01</code>：是否多个进程共享 <code>0: PRIVATE 1: SHARED</code></li><li><code>FLAGS_CLOCKRT = 0x02</code>：是否采用实时时钟来为其设置超时时间</li><li><code>FLAGS_HAS_TIMEOUT = 0x04</code>：是否需要超时唤醒</li></ul></li><li><code>val</code>：锁变量值，如果和<code>*uaddr</code>值相等就阻塞等待，不相等说明有其他进程已经修改了该值，那么会直接返回</li><li><code>abs_time</code>：设置超时唤醒的绝对时间</li><li><code>bitset</code>：设置位掩码，只有当<code>*uaddr</code>指向的值的某位发生变更才被唤醒</li></ul></li><li><code>futex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)</code> <a target=_blank rel=noopener href=https://elixir.bootlin.com/linux/v4.0/source/kernel/futex.c#L1214>源码链接</a><ul><li><code>*uaddr</code>：唤醒在指定用户空间地址指针上阻塞等待的线程</li><li><code>flags</code>：<ul><li><code>FLAGS_SHARED = 0x01</code>：是否多个进程共享 <code>0: PRIVATE 1: SHARED</code></li></ul></li><li><code>nr_wake</code>：唤醒指定数量的线程</li><li><code>bitset</code>：用于比较在调用<code>futex_wait</code>传入的<code>bitset</code>的值是否发生变化，如果没有发生变化则不唤醒</li></ul></li></ul><p>上面介绍了两个函数以及参数的作用，接下来让我们去探究源码，看看是如何实现的</p><blockquote><p>在线源码 <a target=_blank rel=noopener href=https://elixir.bootlin.com/linux/v4.0/source/kernel/futex.c#L2053>futex.c - kernel/futex.c - Linux source code v4.0 - Bootlin Elixir Cross Referencer</a></p></blockquote><h2 id=futex_wait-源码解析><a class=markdownIt-Anchor href=#futex_wait-源码解析></a> futex_wait 源码解析</h2><h3 id=源码流程时序图><a class=markdownIt-Anchor href=#源码流程时序图></a> 源码流程时序图</h3><img src=/posts/991d833e/futex_wait.svg class="" title=futex_wait><p>上面是<code>futex_wait</code>的执行时序，直观了解一下整个的执行过程，下面深究源码，让我们看看互斥锁的底层实现</p><blockquote><p>注意，本文所说的进程语义其实就是线程，在<code>liunx</code>中线程和进程共用一个结构体<code>task_struct</code>，通过内部的两个属性<code>pid</code>和<code>tgid</code>来区分线程与进程<br>如果 <code>pid == tgid</code>是进程，否则就是线程</p></blockquote><h3 id=futex_wait><a class=markdownIt-Anchor href=#futex_wait></a> futex_wait</h3><pre class="line-numbers language-c" data-language=c><code class=language-c><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">futex_wait</span><span class="token punctuation">(</span>u32 __user <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> u32 val<span class="token punctuation">,</span>
		      <span class="token class-name">ktime_t</span> <span class="token operator">*</span>abs_time<span class="token punctuation">,</span> u32 bitset<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">// 如果设置了等待时间，将由定时器唤醒该等待的进程</span>
	<span class="token keyword">struct</span> <span class="token class-name">hrtimer_sleeper</span> timeout<span class="token punctuation">,</span> <span class="token operator">*</span>to <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">restart_block</span> <span class="token operator">*</span>restart<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span>hb<span class="token punctuation">;</span>
	<span class="token comment">// 初始化 futex_q , futex_q 是等待队列中的元素类型</span>
	<span class="token keyword">struct</span> <span class="token class-name">futex_q</span> q <span class="token operator">=</span> futex_q_init<span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
	<span class="token comment">// 通常是 0xffffffff，在调用futex_wake时会判断uaddr的值的bit mask 是否发生改变从而决定是否唤醒</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bitset<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
	q<span class="token punctuation">.</span>bitset <span class="token operator">=</span> bitset<span class="token punctuation">;</span>
	<span class="token comment">// 设置了超时时间，当达到了超时时间会由 hrtimer来重新调度线程</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>abs_time<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		to <span class="token operator">=</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">;</span>
		<span class="token function">hrtimer_init_on_stack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>to<span class="token operator">-></span>timer<span class="token punctuation">,</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> FLAGS_CLOCKRT<span class="token punctuation">)</span> <span class="token operator">?</span>
				      CLOCK_REALTIME <span class="token operator">:</span> CLOCK_MONOTONIC<span class="token punctuation">,</span>
				      HRTIMER_MODE_ABS<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">hrtimer_init_sleeper</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">hrtimer_set_expires_range_ns</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>to<span class="token operator">-></span>timer<span class="token punctuation">,</span> <span class="token operator">*</span>abs_time<span class="token punctuation">,</span>
					     current<span class="token operator">-></span>timer_slack_ns<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

retry<span class="token operator">:</span>
	<span class="token comment">/*
	 * Prepare to wait on uaddr. On success, holds hb lock and increments
	 * q.key refs.
	 */</span>
	<span class="token comment">// 主要是做前置操作</span>
	<span class="token comment">// 1. 对futex_q所要存放的等待队列加锁</span>
	<span class="token comment">// 2. 将存放的等待队列的指针赋值给 hb 地址</span>
	<span class="token comment">// 3. 判断uaddr的值是否等于val，如果等于，那么说明没有其他进程对该地址的值做更改,返回0，否则非0</span>
	ret <span class="token operator">=</span> <span class="token function">futex_wait_setup</span><span class="token punctuation">(</span>uaddr<span class="token punctuation">,</span> val<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hb<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
		<span class="token comment">// 非0，直接跳转到out</span>
		<span class="token keyword">goto</span> out<span class="token punctuation">;</span>
	<span class="token comment">/* queue_me and wait for wakeup, timeout, or a signal. */</span>
	<span class="token comment">// 将 futex_q 入队，并且将当前进程设置为不可调度状态，然后会重新开始调度进程</span>
	<span class="token function">futex_wait_queue_me</span><span class="token punctuation">(</span>hb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 执行到这里就是被唤醒了</span>
	<span class="token comment">/* If we were woken (and unqueued), we succeeded, whatever. */</span>
	ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">/* unqueue_me() drops q.key ref */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">unqueue_me</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token comment">// 是被其他进程唤醒的，直接跳转到 out</span>
		<span class="token keyword">goto</span> out<span class="token punctuation">;</span>
	
	<span class="token comment">// 可能是被定时器给唤醒的</span>
	ret <span class="token operator">=</span> <span class="token operator">-</span>ETIMEDOUT<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>to <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>to<span class="token operator">-></span>task<span class="token punctuation">)</span>
		<span class="token comment">// 设置了定时器，并且定时任务已经执行了，那么就是被定时任务唤醒的，直接调换到out</span>
		<span class="token keyword">goto</span> out<span class="token punctuation">;</span>

	<span class="token comment">/*
	 * We expect signal_pending(current), but we might be the
	 * victim of a spurious wakeup as well.
	 */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">signal_pending</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token comment">// 不是被信号唤醒的,说明是虚假唤醒，重新阻塞等待</span>
		<span class="token keyword">goto</span> retry<span class="token punctuation">;</span>
	<span class="token comment">// 是被信号唤醒的</span>
	ret <span class="token operator">=</span> <span class="token operator">-</span>ERESTARTSYS<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>abs_time<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> out<span class="token punctuation">;</span>
	<span class="token comment">// 和信号有关，但不太了解</span>
	restart <span class="token operator">=</span> <span class="token operator">&amp;</span>current<span class="token operator">-></span>restart_block<span class="token punctuation">;</span>
	restart<span class="token operator">-></span>fn <span class="token operator">=</span> futex_wait_restart<span class="token punctuation">;</span>
	restart<span class="token operator">-></span>futex<span class="token punctuation">.</span>uaddr <span class="token operator">=</span> uaddr<span class="token punctuation">;</span>
	restart<span class="token operator">-></span>futex<span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
	restart<span class="token operator">-></span>futex<span class="token punctuation">.</span>time <span class="token operator">=</span> abs_time<span class="token operator">-></span>tv64<span class="token punctuation">;</span>
	restart<span class="token operator">-></span>futex<span class="token punctuation">.</span>bitset <span class="token operator">=</span> bitset<span class="token punctuation">;</span>
	restart<span class="token operator">-></span>futex<span class="token punctuation">.</span>flags <span class="token operator">=</span> flags <span class="token operator">|</span> FLAGS_HAS_TIMEOUT<span class="token punctuation">;</span>

	ret <span class="token operator">=</span> <span class="token operator">-</span>ERESTART_RESTARTBLOCK<span class="token punctuation">;</span>

out<span class="token operator">:</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 设置了定时任务，将其取消</span>
		<span class="token function">hrtimer_cancel</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>to<span class="token operator">-></span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">destroy_hrtimer_on_stack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>to<span class="token operator">-></span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 返回执行结果</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的注释已经都解释了每行代码的用途，这里总结一下</p><ol><li>如果设置了超时唤醒，那么就会为其设置一个定时器，当超过指定的时间后定时器就会唤醒该进程</li><li>执行<code>futex_wait_setup</code>方法，完成将当前进程所关联的<code>futex_q</code>对象插入到等待队列之前的初始化工作，并且判断它的返回值，如果是非0，那么说明<code>uaddr</code>地址的值已经被更改了，直接返回退出执行</li><li>执行<code>futex_wait_queue_me</code>方法，执行真正的插入等待队列的操作并且将当前进程设置为不可调度的状态，然后执行调度进程<code>schedule</code>函数</li><li>被唤醒了，就检查是什么原因唤醒的当前进程，并且返回对应的返回值，如果是0就说明是被其他进程调用<code>futex_wake</code>唤醒的</li></ol><p>ok，总结了一下流程，接下来让我们具体的看下这些方法做了什么操作</p><h3 id=futex_wait_setup><a class=markdownIt-Anchor href=#futex_wait_setup></a> futex_wait_setup</h3><pre class="line-numbers language-c" data-language=c><code class=language-c><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">futex_wait_setup</span><span class="token punctuation">(</span>u32 __user <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> u32 val<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>
			   <span class="token keyword">struct</span> <span class="token class-name">futex_q</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span><span class="token operator">*</span>hb<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	u32 uval<span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>

	<span class="token comment">/*
	 * Access the page AFTER the hash-bucket is locked.
	 * Order is important:
	 *
	 *   Userspace waiter: val = var; if (cond(val)) futex_wait(&amp;var, val);
	 *   Userspace waker:  if (cond(var)) &#123; var = new; futex_wake(&amp;var); &#125;
	 *
	 * The basic logical guarantee of a futex is that it blocks ONLY
	 * if cond(var) is known to be true at the time of blocking, for
	 * any cond.  If we locked the hash-bucket after testing *uaddr, that
	 * would open a race condition where we could block indefinitely with
	 * cond(var) false, which would violate the guarantee.
	 *
	 * On the other hand, we insert q and release the hash-bucket only
	 * after testing *uaddr.  This guarantees that futex_wait() will NOT
	 * absorb a wakeup if *uaddr does not match the desired values
	 * while the syscall executes.
	 */</span>
retry<span class="token operator">:</span>
	<span class="token comment">// 通过uaddr来计算并初始化futex_q的key</span>
	ret <span class="token operator">=</span> <span class="token function">get_futex_key</span><span class="token punctuation">(</span>uaddr<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> FLAGS_SHARED<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token operator">-></span>key<span class="token punctuation">,</span> VERIFY_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> ret<span class="token punctuation">;</span>

retry_private<span class="token operator">:</span>
	<span class="token comment">// 对futex_q将要存放的等待队列加锁，并返回这个等待队列的指针</span>
	<span class="token operator">*</span>hb <span class="token operator">=</span> <span class="token function">queue_lock</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将在用户空间中uaddr地址的值拷贝到内核空间中的uval地址位置</span>
	ret <span class="token operator">=</span> <span class="token function">get_futex_value_locked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>uval<span class="token punctuation">,</span> uaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 拷贝失败，释放队列锁</span>
		<span class="token function">queue_unlock</span><span class="token punctuation">(</span><span class="token operator">*</span>hb<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 再次从用户空间中将uaddr地址的值拷贝到uval</span>
		ret <span class="token operator">=</span> <span class="token function">get_user</span><span class="token punctuation">(</span>uval<span class="token punctuation">,</span> uaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
			<span class="token comment">// 拷贝失败，跳转到out处</span>
			<span class="token keyword">goto</span> out<span class="token punctuation">;</span>
		<span class="token comment">// 拷贝成功,重试</span>
		<span class="token keyword">goto</span> retry_private<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>uval <span class="token operator">!=</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 如果值不相等了，说明已经有进程(此处其实是线程)修改了锁变量地址中的值</span>
		<span class="token function">queue_unlock</span><span class="token punctuation">(</span><span class="token operator">*</span>hb<span class="token punctuation">)</span><span class="token punctuation">;</span>
		ret <span class="token operator">=</span> <span class="token operator">-</span>EWOULDBLOCK<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

out<span class="token operator">:</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
		<span class="token comment">// 处理多进程共享锁地址的逻辑，内部对私有进程锁是不会处理的</span>
		<span class="token function">put_futex_key</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language=c><code class=language-c><span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">get_futex_key</span><span class="token punctuation">(</span>u32 __user <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> fshared<span class="token punctuation">,</span> <span class="token keyword">union</span> futex_key <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">int</span> rw<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> address <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>uaddr<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm <span class="token operator">=</span> current<span class="token operator">-></span>mm<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token operator">*</span>page_head<span class="token punctuation">;</span>
	<span class="token keyword">int</span> err<span class="token punctuation">,</span> ro <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	 * The futex address must be "naturally" aligned.
	 */</span>
	<span class="token comment">// 计算 uaddr 在内存页内偏移量</span>
	key<span class="token operator">-></span>both<span class="token punctuation">.</span>offset <span class="token operator">=</span> address <span class="token operator">%</span> PAGE_SIZE<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token punctuation">(</span>address <span class="token operator">%</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
	<span class="token comment">// 计算得到 uaddr 所在内存页的首地址</span>
	address <span class="token operator">-=</span> key<span class="token operator">-></span>both<span class="token punctuation">.</span>offset<span class="token punctuation">;</span>
	<span class="token comment">// 判断是否可以访问</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">access_ok</span><span class="token punctuation">(</span>rw<span class="token punctuation">,</span> uaddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>

	<span class="token comment">/*
	 * PROCESS_PRIVATE futexes are fast.
	 * As the mm cannot disappear under us and the 'key' only needs
	 * virtual address, we dont even have to find the underlying vma.
	 * Note : We do have to check 'uaddr' is a valid user address,
	 *        but access_ok() should be faster than find_vma()
	 */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fshared<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 处理私有进程锁，通常是走这个逻辑</span>
		key<span class="token operator">-></span>private<span class="token punctuation">.</span>mm <span class="token operator">=</span> mm<span class="token punctuation">;</span> <span class="token comment">// 内存结构对象</span>
		key<span class="token operator">-></span>private<span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span> <span class="token comment">// 地址</span>
		<span class="token comment">// 针对私有进程锁就是增加内存屏障的作用,保证上面指令以及在该函数之后的指令顺序性</span>
		<span class="token function">get_futex_key_refs</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* implies MB (B) */</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 多进程共享锁逻辑 省略</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language=c><code class=language-c><span class="token comment">/* The key must be already stored in q->key. */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span><span class="token function">queue_lock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">futex_q</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
	<span class="token function">__acquires</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hb<span class="token operator">-></span>lock<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span>hb<span class="token punctuation">;</span>
	<span class="token comment">// 获取futex_q所在的链表 futex_q是在一个hash数组中的链表上</span>
	hb <span class="token operator">=</span> <span class="token function">hash_futex</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	 * Increment the counter before taking the lock so that
	 * a potential waker won't miss a to-be-slept task that is
	 * waiting for the spinlock. This is safe as all queue_lock()
	 * users end up calling queue_me(). Similarly, for housekeeping,
	 * decrement the counter at queue_unlock() when some error has
	 * occurred and we don't end up adding the task to the list.
	 */</span>
	<span class="token comment">// 原子性的增加一个等待进程的数量</span>
	<span class="token function">hb_waiters_inc</span><span class="token punctuation">(</span>hb<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将futex_q的锁指针指向它要存放的等待队列的锁，因为接下来在该队列上做操作,要保证线程安全</span>
	q<span class="token operator">-></span>lock_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>hb<span class="token operator">-></span>lock<span class="token punctuation">;</span>
	<span class="token comment">// 给等待队列加自旋锁</span>
	<span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hb<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* implies MB (A) */</span>
	<span class="token keyword">return</span> hb<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">queue_unlock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span>hb<span class="token punctuation">)</span>
	<span class="token function">__releases</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hb<span class="token operator">-></span>lock<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hb<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">hb_waiters_dec</span><span class="token punctuation">(</span>hb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language=c><code class=language-c><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">get_futex_value_locked</span><span class="token punctuation">(</span>u32 <span class="token operator">*</span>dest<span class="token punctuation">,</span> u32 __user <span class="token operator">*</span>from<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>

	<span class="token function">pagefault_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将在用户空间中form地址的值拷贝到内核空间中的dest地址位置</span>
	ret <span class="token operator">=</span> <span class="token function">__copy_from_user_inatomic</span><span class="token punctuation">(</span>dest<span class="token punctuation">,</span> from<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>u32<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">pagefault_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 拷贝成功返回0</span>
	<span class="token keyword">return</span> ret <span class="token operator">?</span> <span class="token operator">-</span>EFAULT <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>futex_wait_setup</code>主要就做三件事</p><ul><li>调用<code>get_futex_key</code>函数，内部会根据<code>uaddr</code>地址计算<code>futex_q</code>元素的<code>key</code>，并且判断<code>uaddr</code>地址是否可以被访问，然后初始化<code>futex_q</code>的内存结构<code>mm</code>和锁地址<code>address</code>这两个字段</li><li>调用<code>queue_lock(q)</code>函数，对<code>futex_q</code>将要插入的等待队列加锁，并且返回等待队列的地址</li><li>获取<code>uaddr</code>的值并与<code>val</code>判断，如果不相等说明被其他进程更改过了，那么不应该继续执行返回非0，相等则返回0</li></ul><h3 id=futex_wait_queue_me><a class=markdownIt-Anchor href=#futex_wait_queue_me></a> futex_wait_queue_me</h3><p>该函数是<code>futex_wait</code>的关键，完成了阻塞当前进程并重新调度进程执行的功能</p><pre class="line-numbers language-c" data-language=c><code class=language-c><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">futex_wait_queue_me</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span>hb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">futex_q</span> <span class="token operator">*</span>q<span class="token punctuation">,</span>
				<span class="token keyword">struct</span> <span class="token class-name">hrtimer_sleeper</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">/*
	 * The task state is guaranteed to be set before another task can
	 * wake it. set_current_state() is implemented using set_mb() and
	 * queue_me() calls spin_unlock() upon completion, both serializing
	 * access to the hash list and forcing another memory barrier.
	 */</span>
	<span class="token comment">// 设置进程状态为TASK_INTERRUPTIBLE,注意：在liunx内核中只会调度状态为TASK_RUNNING的进程，所以该进程不会被调度了</span>
	<span class="token function">set_current_state</span><span class="token punctuation">(</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将 futex_q 插入到等待队列中，并且会释放等待队列的锁</span>
	<span class="token function">queue_me</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> hb<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/* Arm the timer */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 设置了超时，那么启动定时器来调度唤醒该进程</span>
		<span class="token function">hrtimer_start_expires</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timeout<span class="token operator">-></span>timer<span class="token punctuation">,</span> HRTIMER_MODE_ABS<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hrtimer_active</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timeout<span class="token operator">-></span>timer<span class="token punctuation">)</span><span class="token punctuation">)</span>
			timeout<span class="token operator">-></span>task <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">/*
	 * If we have been removed from the hash list, then another task
	 * has tried to wake us, and we can skip the call to schedule().
	 */</span>
	 <span class="token comment">// 判断当前futex_q的节点是否还在等待队列中,如果不在，说明已经有进程唤醒,那么就不进行进程的调度,避免上下文切换</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">plist_node_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">/*
		 * If the timer has already expired, current will already be
		 * flagged for rescheduling. Only call schedule if there
		 * is no timeout, or if it has yet to expire.
		 */</span>
		<span class="token comment">// 没有设置定时唤醒或者已经定时器没有超时</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout <span class="token operator">||</span> timeout<span class="token operator">-></span>task<span class="token punctuation">)</span>
			<span class="token comment">// 重新调度进程</span>
			<span class="token function">freezable_schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 被唤醒了(被其他进程唤醒或者是定时器唤醒),设置进程的状态为TASK_RUNNING(这里是防御性编程，无论上面哪种唤醒方式，在调度该线程时都会将状态设置为TASK_RUNNING)</span>
	<span class="token comment">// 可以查看 core.c ttwu_do_wakeup函数实现</span>
	<span class="token function">__set_current_state</span><span class="token punctuation">(</span>TASK_RUNNING<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>queue_me：将futex_q所在节点插入到等待队列中</p><pre class="line-numbers language-c" data-language=c><code class=language-c><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">queue_me</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">futex_q</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span>hb<span class="token punctuation">)</span>
	<span class="token function">__releases</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hb<span class="token operator">-></span>lock<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> prio<span class="token punctuation">;</span>

	<span class="token comment">/*
	 * The priority used to register this element is
	 * - either the real thread-priority for the real-time threads
	 * (i.e. threads with a priority lower than MAX_RT_PRIO)
	 * - or MAX_RT_PRIO for non-RT threads.
	 * Thus, all RT-threads are woken first in priority order, and
	 * the others are woken last, in FIFO order.
	 */</span>
	prio <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>current<span class="token operator">-></span>normal_prio<span class="token punctuation">,</span> MAX_RT_PRIO<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">plist_node_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>list<span class="token punctuation">,</span> prio<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将futex_q所在的节点插入到等待队列中 注意: 虽然取名是 list 但其实是个节点类型</span>
	<span class="token function">plist_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hb<span class="token operator">-></span>chain<span class="token punctuation">)</span><span class="token punctuation">;</span>
	q<span class="token operator">-></span>task <span class="token operator">=</span> current<span class="token punctuation">;</span>
	<span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hb<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// plist_add方法</span>
<span class="token keyword">void</span> <span class="token function">plist_add</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">plist_node</span> <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">plist_head</span> <span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>futex_wait_queue_me</code>函数总结</p><ol><li>设置当前进程的状态为<code>TASK_INTERRUPTIBLE</code>,处于该状态的进程不会被内核调度</li><li>将代表当前进程的<code>futex_q</code>插入到等待队列中，并释放等待队列的锁</li><li>判断<code>futex_q</code>是否还在等待队列，因为已经释放了等待队列的锁了，可能在释放之后就有进程马上调用了<code>futex_wake</code>唤醒了该进程，那么就不需要重新调度，直接返回即可，如果还在，那么就调用<code>schedule</code>来重新调度进程<ul><li>注意：<code>freezable_schedule</code>内部会调用<code>schedule</code>，该函数才是真正实现了调度进程的功能</li></ul></li></ol><h3 id=总结><a class=markdownIt-Anchor href=#总结></a> 总结</h3><p><code>futex_wait</code>的完整流程</p><ol><li>如果设置了超时唤醒，那么会为其设置一个定时任务，当达到指定的时间但仍未取消该任务，就由定时任务来唤醒当前进程</li><li>调用<code>futex_wait_setup</code>来完成将代表当前进程的<code>futex_q</code>插入到等待队列之前的准备工作，在该函数内部会根据<code>uaddr</code>的地址来计算并且初始化<code>futex_q</code>的<code>key</code>属性，然后对<code>futex_q</code>要插入的等待队列加锁，然后判断<code>uaddr</code>是否可以访问，如果可以便获取<code>uaddr</code>的值并且与<code>val</code>比较，如果相等，说明没有被其他进程更改过，那么可以进行阻塞操作返回0，如果不相等那么释放等待队列锁然后返回非0</li><li>根据<code>futex_wait_setup</code>的返回值来判断，如果是非0，那么直接退出返回，如果是0，那么继续向下执行，调用<code>futex_wait_queue_me</code>来完成阻塞当前进程并重新调度进程的操作</li><li>在<code>futex_wait_queue_me</code>中，首先将当前进程状态设置为<code>TASK_INTERRUPTIBLE</code>，将代表当前进程的<code>futex_q</code>插入到等待队列中，并且释放锁，在真正通过<code>schedule</code>函数重新调度进程之前会做一次检查，判断<code>futex_q</code>是否还在等待队列中，如果不在说明就在释放锁之后立马就有进程唤醒了当前进程，那么不需要通过<code>schedule</code>函数重新调度了，如果还在，那么就通过<code>schedule</code>函数来重新调度进程</li></ol><h2 id=futex_wake-源码解析><a class=markdownIt-Anchor href=#futex_wake-源码解析></a> futex_wake 源码解析</h2><p><code>futex_wake</code> 源码相对<code>futex_wait</code>来说要简单许多，接下来让我们探究一下<code>futex_wake</code>是如何唤醒在等待队列上的进程的</p><h3 id=futex_wake-源码时序图><a class=markdownIt-Anchor href=#futex_wake-源码时序图></a> futex_wake 源码时序图</h3><pre class=mermaid>sequenceDiagram
	futex_wake->>get_futex_key: 通过uaddr计算获取futex_key
	futex_wake->>hash_futex: 通过futex_key定位找到等待队列的头节点
	futex_wake->>hb_waiters_pending: 判断等待队列上的waiter属性是否为0，从而来决定是否继续执行
	Note over futex_wake,hb_waiters_pending: 如果为0说明没有进程在等待,直接返回<br>如果不为0说明存在需要唤醒的进程,那么对等待队列加锁,然后通过等待队列头节点进行遍历
	futex_wake-->>wake_futex: 唤醒指定进程
	rect rgb(66, 184, 131)
	wake_futex-->>__unqueue_futex: 将代表当前进程的futex_q从等待队列中移除,并释放队列锁
	wake_futex-->>wake_up_state: 将指定进程设置为可调度执行的状态,然后将其插入到相应的调度队列中,等待内核调度
	end</pre><h3 id=futex_wake><a class=markdownIt-Anchor href=#futex_wake></a> futex_wake</h3><pre class="line-numbers language-c" data-language=c><code class=language-c><span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">futex_wake</span><span class="token punctuation">(</span>u32 __user <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> nr_wake<span class="token punctuation">,</span> u32 bitset<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span>hb<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">futex_q</span> <span class="token operator">*</span>this<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
	<span class="token keyword">union</span> futex_key key <span class="token operator">=</span> FUTEX_KEY_INIT<span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bitset<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
	<span class="token comment">// 通过 uaddr 计算futex_q 的 key</span>
	ret <span class="token operator">=</span> <span class="token function">get_futex_key</span><span class="token punctuation">(</span>uaddr<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> FLAGS_SHARED<span class="token punctuation">,</span> <span class="token operator">&amp;</span>key<span class="token punctuation">,</span> VERIFY_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">goto</span> out<span class="token punctuation">;</span>
	<span class="token comment">// 通过key找到futex_q所在的等待队列 </span>
	hb <span class="token operator">=</span> <span class="token function">hash_futex</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">/* Make sure we really have tasks to wakeup */</span>
	<span class="token comment">// 判断等待队列的waiters属性是否大于0，决定是否执行接下来的唤醒动作，如果等于0，说明没有等待队列为空，直接返回</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hb_waiters_pending</span><span class="token punctuation">(</span>hb<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">goto</span> out_put_key<span class="token punctuation">;</span>
	<span class="token comment">// 接下来就要对等待队列操作了，对等待队列加锁</span>
	<span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hb<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 遍历等待队列列表</span>
	<span class="token function">plist_for_each_entry_safe</span><span class="token punctuation">(</span>this<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hb<span class="token operator">-></span>chain<span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 比较等待队列元素上的key是否与计算得到的key相等</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">match_futex</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>this<span class="token operator">-></span>key<span class="token punctuation">,</span> <span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>this<span class="token operator">-></span>pi_state <span class="token operator">||</span> this<span class="token operator">-></span>rt_waiter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				ret <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token comment">/* Check if one of the bits is set in both bitsets */</span>
			<span class="token comment">// 匹配成功,判断位图上的bit位是否发生变化,如果没有变化,则不会唤醒,通常 bitset 是一个32位全为1的的数,所以都会直接走唤醒的流程</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>this<span class="token operator">-></span>bitset <span class="token operator">&amp;</span> bitset<span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token comment">// 唤醒当前futex_q元素上关联的进程</span>
			<span class="token function">wake_futex</span><span class="token punctuation">(</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 唤醒指定数量的进程后就退出遍历</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>ret <span class="token operator">>=</span> nr_wake<span class="token punctuation">)</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 释放锁</span>
	<span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hb<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
out_put_key<span class="token operator">:</span>
	<span class="token comment">// 销毁key</span>
	<span class="token function">put_futex_key</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token operator">:</span>
	<span class="token comment">// 返回唤醒的进程数量</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>futex_wake 内部完成如下功能</p><ol><li>通过<code>uaddr</code>来计算并获取<code>futex_q</code>的key，通过<code>key</code>从等待队列hash表中获取对应的等待队列</li><li>对等待队列加锁，循环遍历等待队列列表中的元素，判断元素上的<code>key</code>是否与<code>futex_q</code>的<code>key</code>匹配，如果匹配，调用<code>wake_futex</code>执行唤醒操作，唤醒等待队列上指定数量阻塞等待的进程后就会退出遍历</li><li>释放等待队列锁，返回唤醒的进程数量</li></ol><h4 id=wake_futex><a class=markdownIt-Anchor href=#wake_futex></a> wake_futex</h4><pre class="line-numbers language-c" data-language=c><code class=language-c><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">wake_futex</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">futex_q</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">// futex_q关联的进程结构体 task_struct</span>
	<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p <span class="token operator">=</span> q<span class="token operator">-></span>task<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WARN</span><span class="token punctuation">(</span>q<span class="token operator">-></span>pi_state <span class="token operator">||</span> q<span class="token operator">-></span>rt_waiter<span class="token punctuation">,</span> <span class="token string">"refusing to wake PI futex\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	 * We set q->lock_ptr = NULL _before_ we wake up the task. If
	 * a non-futex wake up happens on another CPU then the task
	 * might exit and p would dereference a non-existing task
	 * struct. Prevent this by holding a reference on p across the
	 * wake up.
	 */</span>
	<span class="token comment">// 通过调用 get_task_struct(p) 增加引用计数，即使任务在唤醒过程中被其他事件触发退出，由于引用计数不为 0，`struct task_struct` 结构体也不会被立即释放</span>
	<span class="token function">get_task_struct</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将 futex_q 元素从等待队列中移除</span>
	<span class="token function">__unqueue_futex</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*
	 * The waiting task can free the futex_q as soon as
	 * q->lock_ptr = NULL is written, without taking any locks. A
	 * memory barrier is required here to prevent the following
	 * store to lock_ptr from getting ahead of the plist_del.
	 */</span>
	<span class="token comment">// 内存屏障，保证指令顺序性</span>
	<span class="token function">smp_wmb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 释放对等待队列的锁引用</span>
	q<span class="token operator">-></span>lock_ptr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token comment">// 执行唤醒操作 底层会将进程p的状态设置为TASK_RUNNING,然后将它放入到相应的调度队列中，等待cpu调度</span>
	<span class="token comment">// TASK_NORMAL 是一个状态掩码,在唤醒时会根据任务p的状态来做与操作,判断当前状态是否支持唤醒</span>
	<span class="token comment">// TASK_NORMAL = TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE</span>
	<span class="token function">wake_up_state</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> TASK_NORMAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将任务p的引用计数-1</span>
	<span class="token function">put_task_struct</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">__unqueue_futex</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">futex_q</span> <span class="token operator">*</span>q<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span>hb<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WARN_ON_SMP</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token operator">-></span>lock_ptr <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">spin_is_locked</span><span class="token punctuation">(</span>q<span class="token operator">-></span>lock_ptr<span class="token punctuation">)</span><span class="token punctuation">)</span>
	    <span class="token operator">||</span> <span class="token function">WARN_ON</span><span class="token punctuation">(</span><span class="token function">plist_node_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token comment">// 通过 container_of 找到 futex_q 所在的等待队列</span>
	hb <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>q<span class="token operator">-></span>lock_ptr<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span><span class="token punctuation">,</span> lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将 futex_q 从等待队列上移除</span>
	<span class="token function">plist_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hb<span class="token operator">-></span>chain<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 将等待队列上的waiters属性自减1</span>
	
	<span class="token function">hb_waiters_dec</span><span class="token punctuation">(</span>hb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>增加<code>futex_q</code>所关联的任务结构体对象引用计数，将代表当前进程的<code>futex_q</code>元素从等待队列中移除并对等待队列的<code>waiters</code>自减1，然后释放<code>futex_q</code>对等待队列锁的引用</li><li>调用<code>wake_up_state</code>函数来唤醒指定的进程，对应之前的任务的引用计数+1，此时需要调用<code>put_task_strcut</code>来将任务的引用计数-1</li></ol><p><code>wake_up_state</code>细节</p><ul><li><code>wake_up_state</code> 是定义在 <code>kernel/sched/core.c</code>中的函数，在内部会调用<code>try_to_wake_up</code>函数来唤醒指定进程，值得一提的是：在<code>futex_wait</code>中定义的定时任务也是通过该函数来完成唤醒进程的功能的，该函数最底层会调用<code>ttwu_do_wakeup</code>将进程标记为<code>TASK_RUNNING</code>可运行状态，然后会将进程插入到相应的调度队列中，等待内核调度</li></ul></article><div class=post-copyright><div class=post-copyright__author><span class=post-copyright-meta><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class=post-copyright-info><a href=https://juzzia.github.io>Juzzia</a></span></div><div class=post-copyright__type><span class=post-copyright-meta><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class=post-copyright-info><a href=https://juzzia.github.io/posts/991d833e.html>https://juzzia.github.io/posts/991d833e.html</a></span></div><div class=post-copyright__notice><span class=post-copyright-meta><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class=post-copyright-info>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href=https://juzzia.github.io target=_blank>Juzzia's Blog</a>！</span></div></div><div class=tag_share><div class=post-meta__tag-list></div><div class=post_share><div class=social-share data-image=/img/avatar.jpg data-sites=wechat,weibo,qq></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css media=print onload='this.media="all"'><script src=https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js defer=defer></script></div></div><div class=post-reward><div class=reward-button><i class="fas fa-qrcode"></i>赞助</div><div class=reward-main><ul class=reward-all><li class=reward-item><a href=https://s2.loli.net/2024/08/01/jL2klE39vx5Ft4r.jpg target=_blank><img class=post-qr-code-img src=https://s2.loli.net/2024/08/01/jL2klE39vx5Ft4r.jpg alt=wechat></a><div class=post-qr-code-desc>wechat</div></li><li class=reward-item><a href=https://s2.loli.net/2024/08/01/2s3UCWdlneAiYRa.jpg target=_blank><img class=post-qr-code-img src=https://s2.loli.net/2024/08/01/2s3UCWdlneAiYRa.jpg alt=alipay></a><div class=post-qr-code-desc>alipay</div></li></ul></div></div><nav class=pagination-post id=pagination><div class="prev-post pull-left"><a href=/posts/bcc098b4.html title="Liunx 任务调度"><div class=cover style=background:var(--default-bg-color)></div><div class=pagination-info><div class=label>上一篇</div><div class=prev_info>Liunx 任务调度</div></div></a></div><div class="next-post pull-right"><a href=/posts/f95e72b6.html title="字节码解释器 Interpreter"><div class=cover style=background:var(--default-bg-color)></div><div class=pagination-info><div class=label>下一篇</div><div class=next_info>字节码解释器 Interpreter</div></div></a></div></nav><hr class=custom-hr><div id=post-comment><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class=comment-wrap><div><div id=giscus-wrap></div></div></div></div></div><div class=aside-content id=aside-content><div class="card-widget card-info"><div class=is-center><div class=avatar-img><img src=/img/avatar.jpg onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt=avatar></div><div class=author-info__name>Juzzia</div><div class=author-info__description>分享技术，开发经验，学习总结</div></div><div class="card-info-data site-data is-center"><a href=/archives/ ><div class=headline>文章</div><div class=length-num>10</div></a><a href=/tags/ ><div class=headline>标签</div><div class=length-num>4</div></a><a href=/categories/ ><div class=headline>分类</div><div class=length-num>5</div></a></div><a id=card-info-btn target=_blank rel=noopener href=https://github.com/juzzia><i class="fab fa-github"></i><span>github</span></a><div class="card-info-social-icons is-center"><a class=social-icon href=https://github.com/juzzia target=_blank title=Github><i class="fab fa-github" style=color:#24292e></i></a><a class=social-icon href=mailto:juzzia@github.com target=_blank title=Email><i class="fas fa-envelope" style=color:#4a7dbe></i></a></div></div><div class=sticky_layout><div class=card-widget id=card-toc><div class=item-headline><i class="fas fa-stream"></i><span>目录</span><span class=toc-percentage></span></div><div class="toc-content is-expand"><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E8%83%8C%E6%99%AF><span class=toc-number>1.</span> <span class=toc-text>背景</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E9%94%81><span class=toc-number>2.</span> <span class=toc-text>锁</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#java-lock><span class=toc-number>2.1.</span> <span class=toc-text>Java Lock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%BB%8B%E7%BB%8D><span class=toc-number>3.</span> <span class=toc-text>介绍</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#futex_wait-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90><span class=toc-number>4.</span> <span class=toc-text>futex_wait 源码解析</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE><span class=toc-number>4.1.</span> <span class=toc-text>源码流程时序图</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#futex_wait><span class=toc-number>4.2.</span> <span class=toc-text>futex_wait</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#futex_wait_setup><span class=toc-number>4.3.</span> <span class=toc-text>futex_wait_setup</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#futex_wait_queue_me><span class=toc-number>4.4.</span> <span class=toc-text>futex_wait_queue_me</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E6%80%BB%E7%BB%93><span class=toc-number>4.5.</span> <span class=toc-text>总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#futex_wake-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90><span class=toc-number>5.</span> <span class=toc-text>futex_wake 源码解析</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#futex_wake-%E6%BA%90%E7%A0%81%E6%97%B6%E5%BA%8F%E5%9B%BE><span class=toc-number>5.1.</span> <span class=toc-text>futex_wake 源码时序图</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#futex_wake><span class=toc-number>5.2.</span> <span class=toc-text>futex_wake</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#wake_futex><span class=toc-number>5.2.1.</span> <span class=toc-text>wake_futex</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class=item-headline><i class="fas fa-history"></i><span>最新文章</span></div><div class=aside-list><div class="aside-list-item no-cover"><div class=content><a class=title href=/posts/1fe4afce.html title="字节码指令执行过程 BytecodeInterpreter">字节码指令执行过程 BytecodeInterpreter</a><time datetime=2025-03-07T13:34:00.000Z title="发表于 2025-03-07 21:34:00">2025-03-07</time></div></div><div class="aside-list-item no-cover"><div class=content><a class=title href=/posts/1a5fbe08.html title=CPU缓存与MESI协议>CPU缓存与MESI协议</a><time datetime=2025-03-04T12:42:00.000Z title="发表于 2025-03-04 20:42:00">2025-03-04</time></div></div><div class="aside-list-item no-cover"><div class=content><a class=title href=/posts/bcc098b4.html title="Liunx 任务调度">Liunx 任务调度</a><time datetime=2025-02-24T13:52:00.000Z title="发表于 2025-02-24 21:52:00">2025-02-24</time></div></div><div class="aside-list-item no-cover"><div class=content><a class=title href=/posts/991d833e.html title="Liunx Futex">Liunx Futex</a><time datetime=2025-02-22T15:33:00.000Z title="发表于 2025-02-22 23:33:00">2025-02-22</time></div></div><div class="aside-list-item no-cover"><div class=content><a class=title href=/posts/f95e72b6.html title="字节码解释器 Interpreter">字节码解释器 Interpreter</a><time datetime=2025-02-18T14:45:00.000Z title="发表于 2025-02-18 22:45:00">2025-02-18</time></div></div></div></div></div></div></main></div><div id=rightside><div id=rightside-config-hide><button id=readmode type=button title=阅读模式><i class="fas fa-book-open"></i></button><button id=darkmode type=button title=浅色和深色模式转换><i class="fas fa-adjust"></i></button><button id=hide-aside-btn type=button title=单栏和双栏切换><i class="fas fa-arrows-alt-h"></i></button></div><div id=rightside-config-show><button id=rightside-config type=button title=设置><i class="fas fa-cog fa-spin"></i></button><button class=close id=mobile-toc-button type=button title=目录><i class="fas fa-list-ul"></i></button><a id=to_comment href=#post-comment title=直达评论><i class="fas fa-comments"></i></a><button id=go-up type=button title=回到顶部><span class=scroll-percent></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class=js-pjax><script>(()=>{var e=()=>{var e;0!==(e=document.querySelectorAll("pre > code.mermaid")).length&&e.forEach(e=>{var t=document.createElement("div");t.className="mermaid-wrap",t.innerHTML=`<pre class="mermaid-src" hidden>${e.textContent}</pre>`,e.parentNode.replaceWith(t)});let t=document.querySelectorAll("#article-container .mermaid");0!==t.length&&(e=()=>(e=>{window.loadMermaid=!0;let c="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach((e,t)=>{let n=e.firstElementChild;e="%%{init:{ 'theme':'"+c+"'}}%%\n"+n.textContent;let i=mermaid.render("mermaid-"+t,e);"string"==typeof i?(t=i,n.insertAdjacentHTML("afterend",t)):(i.then(({svg:e})=>{n.insertAdjacentHTML("afterend",e)}),setTimeout(()=>{var e=document.getElementsByTagName("svg");Array.from(e).forEach((e,t)=>{o(e)})},3e3))})})(t),btf.addGlobalFn("themeChange",e,"mermaid"),window.loadMermaid?e():btf.getScript("https://cdn.jsdelivr.net/npm/mermaid@11.0.0/dist/mermaid.min.js").then(e))};let o=l=>{let u=1,m=0,h=0,c=!1,o,d,r=0,e=!1,t=1,n=0,i=0;function a(){u=t,m=n,h=i,e=!1,s()}function s(){l.style.transform=`translate(${m}px, ${h}px) scale(${u})`}l.addEventListener("wheel",function(e){e.preventDefault();var t=0<e.deltaY?-.04:.04,n=(t=Math.min(Math.max(u+t,1),2.3))/u,i=l.getBoundingClientRect(),c=(e.clientX-i.left)/i.width,e=(e.clientY-i.top)/i.height,i=l.getBBox(),c=c*i.width,e=e*i.height;m=m*n-c*(n-1),h=h*n-e*(n-1),u=t,s()}),l.addEventListener("mousedown",function(e){c=!0,o=e.clientX,d=e.clientY,l.style.cursor="grabbing"}),document.addEventListener("mousemove",function(e){c&&(m+=e.clientX-o,h+=e.clientY-d,o=e.clientX,d=e.clientY,s())}),document.addEventListener("mouseup",function(){c=!1,l.style.cursor="grab"}),l.parentElement.addEventListener("dblclick",function(e){var t=Date.now();a(),r=t}),l.addEventListener("touchstart",function(e){if(1===e.touches.length&&((t=Date.now())-r<300&&(n=Date.now(),a(),r=n),r=t),1===(n=e).touches.length)c=!0,o=n.touches[0].clientX,d=n.touches[0].clientY;else if(2===n.touches.length){var t=n.touches[0].clientX-n.touches[1].clientX,n=n.touches[0].clientY-n.touches[1].clientY;let o=Math.sqrt(t*t+n*n),d=m,r=h,a=u;function i(e){var t,n,i,c;2===e.touches.length&&(t=e.touches[0].clientX-e.touches[1].clientX,n=e.touches[0].clientY-e.touches[1].clientY,t=Math.sqrt(t*t+n*n)/o,n=Math.min(Math.max(a*t,.5),1.15),c=(e.touches[0].clientX+e.touches[1].clientX)/2-l.getBoundingClientRect().left,e=(e.touches[0].clientY+e.touches[1].clientY)/2-l.getBoundingClientRect().top,i=l.getBBox(),c=c/l.getBoundingClientRect().width*i.width,e=e/l.getBoundingClientRect().height*i.height,m=d*t-c*(t-1),h=r*t-e*(t-1),u=n,s())}document.addEventListener("touchmove",i),document.addEventListener("touchend",function e(){document.removeEventListener("touchmove",i),document.removeEventListener("touchend",e)})}}),document.addEventListener("touchend",function(){c=!1})};btf.addGlobalFn("encrypt",e,"mermaid"),window.pjax?e():document.addEventListener("DOMContentLoaded",e)})()</script><script>(()=>{let s=t=>"dark"===t?"dark":"light";var t=()=>{var t,e=Object.assign({src:"https://giscus.app/client.js","data-repo":"juzzia/blog-comment","data-repo-id":"R_kgDOMc3hsw","data-category-id":"DIC_kwDOMc3hs84ChTYG","data-mapping":"pathname","data-theme":s(document.documentElement.getAttribute("data-theme")),"data-reactions-enabled":"1",crossorigin:"anonymous",async:!0},{"data-input-position":"top","data-emit-metadata":1,"data-lang":"zh-CN"}),a=document.createElement("script");for(t in e)a.setAttribute(t,e[t]);document.getElementById("giscus-wrap").appendChild(a)};function e(t){var e=document.querySelector("#post-meta .gsc-comments-count");e&&(e.textContent=t)}window.addEventListener("message",function(t){"https://giscus.app"===t.origin&&"object"==typeof t.data&&t.data.giscus&&((t=t.data.giscus).error?e(0):t.discussion&&e(t.discussion.totalCommentCount+t.discussion.totalReplyCount))}),btf.addGlobalFn("themeChange",t=>{var e;t={setConfig:{theme:s(t)}},(e=document.querySelector("iframe.giscus-frame"))&&e.contentWindow.postMessage({giscus:t},"https://giscus.app")},"giscus"),t()})()</script></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css media=print onload='this.media="all"'><script src=https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js></script><script src=https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js></script><script async data-pjax src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><div id=local-search><div class=search-dialog><nav class=search-nav><span class=search-dialog-title>搜索</span><span id=loading-status></span><button class=search-close-button><i class="fas fa-times"></i></button></nav><div class=is-center id=loading-database><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class=search-wrap><div id=local-search-input><div class=local-search-box><input class=local-search-box--input placeholder=搜索文章 type=text></div></div><hr><div id=local-search-results></div><div id=local-search-stats-wrap></div></div></div><div id=search-mask></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>