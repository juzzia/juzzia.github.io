<!DOCTYPE html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><title>JVM Atomic源码解析 | Juzzia's Blog</title><meta name=author content=Juzzia><meta name=copyright content=Juzzia><meta name=format-detection content="telephone=no"><meta name=theme-color content=ffffff><meta name=description content="引言 在日常工作的过程中，常常会使用到一些共享变量来监控某些指标，比如IM系统中为了保证服务端转发消息给客户端时的消息服务质量，我借鉴了TCP的超时重传机制，当通过channel将消息推送给客户端后，达到一定的时间，服务端还没有收到客户端对该消息的ack消息，那么就认为该消息丢失，会触发重传，为了能够掌握某个节点的消息质量情况和超时重传队列的长度，我对重传的次数以及队列的长度都使用了Metric"><meta property=og:type content=article><meta property=og:title content="JVM Atomic源码解析"><meta property=og:url content=https://juzzia.github.io/posts/6961ed95.html><meta property=og:site_name content="Juzzia&#39;s Blog"><meta property=og:description content="引言 在日常工作的过程中，常常会使用到一些共享变量来监控某些指标，比如IM系统中为了保证服务端转发消息给客户端时的消息服务质量，我借鉴了TCP的超时重传机制，当通过channel将消息推送给客户端后，达到一定的时间，服务端还没有收到客户端对该消息的ack消息，那么就认为该消息丢失，会触发重传，为了能够掌握某个节点的消息质量情况和超时重传队列的长度，我对重传的次数以及队列的长度都使用了Metric"><meta property=og:locale content=zh_CN><meta property=og:image content=https://juzzia.github.io/img/avatar.jpg><meta property=article:published_time content=2025-02-15T18:16:00.000Z><meta property=article:modified_time content=2025-03-13T15:22:00.000Z><meta property=article:author content=Juzzia><meta property=article:tag content=源码><meta property=article:tag content=JVM><meta name=twitter:card content=summary><meta name=twitter:image content=https://juzzia.github.io/img/avatar.jpg><link rel="shortcut icon" href=/img/log.svg><link rel=canonical href=https://juzzia.github.io/posts/6961ed95.html><link rel=preconnect href=//cdn.jsdelivr.net><link rel=preconnect href=//hm.baidu.com><link rel=preconnect href=//busuanzi.ibruce.info><meta name=msvalidate.01 content=606EBFCBDED9F21417F108AFF320F465><link rel=stylesheet href="/css/index.css?v=4.13.0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css media=print onload='this.media="all"'><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?344a26e9d7e5894ce499ae53b475d975",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script><script>let GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:5,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"prismjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!0,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id=config-diff>var GLOBAL_CONFIG_SITE={title:"JVM Atomic源码解析",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-03-13 23:22:00"}</script><script>(e=>{e.saveToLocal={set:(e,t,a)=>{var o;0!==a&&(o=Date.now(),localStorage.setItem(e,JSON.stringify({value:t,expiry:o+864e5*a})))},get:e=>{var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!(Date.now()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=(o,n={})=>new Promise((t,e)=>{let a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},Object.keys(n).forEach(e=>{a.setAttribute(e,n[e])}),document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{let a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel=stylesheet href=/css/callout/callout_blocks.css><link rel=stylesheet href=/css/mermaid.css><link rel=stylesheet href=/css/custom.css><meta name=generator content="Hexo 7.3.0"></head><body><div id=web_bg></div><div id=sidebar><div id=menu-mask></div><div id=sidebar-menus><div class="avatar-img is-center"><img src=/img/avatar.jpg onerror='onerror=null,src="/img/friend_404.gif"' alt=avatar></div><div class="sidebar-site-data site-data is-center"><a href=/archives/ ><div class=headline>文章</div><div class=length-num>10</div></a><a href=/tags/ ><div class=headline>标签</div><div class=length-num>4</div></a><a href=/categories/ ><div class=headline>分类</div><div class=length-num>5</div></a></div><hr class=custom-hr><div class=menus_items><div class=menus_item><a class=site-page href=/ ><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class=menus_item><a class=site-page href=/archives/ ><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class=menus_item><a class=site-page href=/tags/ ><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class=menus_item><a class=site-page href=/categories/ ><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class=menus_item><a class=site-page href=/about/ ><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class=post id=body-wrap><header class=not-top-img id=page-header><nav id=nav><span id=blog-info><a href=/ title="Juzzia's Blog"><span class=site-name>Juzzia's Blog</span></a></span><div id=menus><div id=search-button><a class="site-page social-icon search" href=javascript:void(0);><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class=menus_items><div class=menus_item><a class=site-page href=/ ><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class=menus_item><a class=site-page href=/archives/ ><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class=menus_item><a class=site-page href=/tags/ ><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class=menus_item><a class=site-page href=/categories/ ><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class=menus_item><a class=site-page href=/about/ ><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id=toggle-menu><a class=site-page href=javascript:void(0);><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class=layout id=content-inner><div id=post><div id=post-info><h1 class=post-title>JVM Atomic源码解析</h1><div id=post-meta><div class=meta-firstline><span class=post-meta-date><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class=post-meta-label>发表于</span><time datetime=2025-02-15T18:16:00.000Z title="发表于 2025-02-16 02:16:00">2025-02-16</time></span><span class=post-meta-categories><span class=post-meta-separator>|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class=post-meta-categories href=/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ >源码分析</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class=post-meta-categories href=/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/hotspot/ >hotspot</a></span></div><div class=meta-secondline><span class=post-meta-separator>|</span><span class=post-meta-wordcount><i class="far fa-file-word fa-fw post-meta-icon"></i><span class=post-meta-label>字数总计:</span><span class=word-count>3.9k</span><span class=post-meta-separator>|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class=post-meta-label>阅读时长:</span><span>12分钟</span></span><span class=post-meta-separator>|</span><span class=post-meta-pv-cv id="" data-flag-title="JVM Atomic源码解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class=post-meta-label>阅读量:</span><span id=busuanzi_value_page_pv><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class=post-meta-separator>|</span><span class=post-meta-commentcount><i class="far fa-comments fa-fw post-meta-icon"></i><span class=post-meta-label>评论数:</span><a href=/posts/6961ed95.html#post-comment><span class=gsc-comments-count><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><article class=post-content id=article-container><h1 id=引言><a class=markdownIt-Anchor href=#引言></a> 引言</h1><p>在日常工作的过程中，常常会使用到一些<code>共享变量</code>来监控某些指标，比如<code>IM系统</code>中为了保证服务端转发消息给客户端时的消息服务质量，我借鉴了<code>TCP</code>的超时重传机制，当通过<code>channel</code>将消息推送给客户端后，达到一定的时间，服务端还没有收到客户端对该消息的<code>ack</code>消息，那么就认为该消息丢失，会触发重传，为了能够掌握某个节点的消息质量情况和超时重传队列的长度，我对重传的次数以及队列的长度都使用了<code>Metrics</code>进行监控，而为了确保在多线程环境下累加重传的次数的线程安全性，我采用了<code>AtomicLong</code>用来计算重传次数计数，<code>AtomicLong</code>称为原子变量，内部利用<code>CAS</code>指令自旋的方式来完成值的比较和更新，确保了操作的线程安全，但是其底层是如何保证的呢，保留疑问，跟随本文寻找答案</p><h1 id=atomiclong><a class=markdownIt-Anchor href=#atomiclong></a> AtomicLong</h1><p>首先通过阅读Java层面的<code>AtomicLong</code>的源码，了解下它的自增实现</p><pre class="line-numbers language-java" data-language=java><code class=language-java><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicLong</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// setup to use Unsafe.compareAndSwapLong for updates</span>
    <span class="token comment">// Unsafe 提供了很多最底层的操作，此处主要是用到其内部定义的CAS相关的方法</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Unsafe</span> unsafe <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>
    <span class="token comment">// 当前机器是否支持8字节的长整型的cas操作,如果不支持,为了确保原子性的读取和写入,会使用锁的方式来操作共享变量 value，比如32位机器就是false</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token constant">VM_SUPPORTS_LONG_CAS</span> <span class="token operator">=</span> <span class="token class-name">VMSupportsCS8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
	        <span class="token comment">// 获取AtomicLong类的属性value在实例数据区中的偏移量</span>
            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span>objectFieldOffset
                <span class="token punctuation">(</span><span class="token class-name">AtomicLong</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// volatile 修饰,保证当有线程修改该变量的值对其他线程的可见性</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> value<span class="token punctuation">;</span>

	<span class="token comment">// 原子性的递增1</span>
	<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 通过unsafe来完成</span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Unsafe类</p><pre class="line-numbers language-java" data-language=java><code class=language-java><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Unsafe</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> object<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">long</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">long</span> result<span class="token punctuation">;</span>
	<span class="token comment">// 通过自旋的方式给指定的属性设置值</span>
	<span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 获取基于object对象指定offset的属性值</span>
		result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getLongVolatile</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 比较该属性的值是否等于目标值result,如果等于,那么就更新为result + value,如果更新失败，再次重试</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> result<span class="token punctuation">,</span> result <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// cas成功的目标值</span>
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 获取对象属性的值</span>
	<span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">getLongVolatile</span><span class="token punctuation">(</span><span class="token class-name">Object</span> object<span class="token punctuation">,</span> <span class="token keyword">long</span> fieldOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// native 方法</span>
	<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">long</span> var4<span class="token punctuation">,</span> <span class="token keyword">long</span> var6<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<code>AtomicLong#getAndIncrement</code>方法内部直接使用了<code>Unsafe#getAndAddLong</code>方法来完成自增1的操作，在<code>unsafe</code>方法内部会一直自旋获取<code>AtomicLong</code>对象属性<code>value</code>的值，然后<code>cas</code>更新<code>value</code>，如果更新失败那么继续重试</p><p>上面的方法简洁明了，但是却看不到底层是如何处理的，所以为了搞清细节，继续深究源码</p><h1 id=读取-计算-更新><a class=markdownIt-Anchor href=#读取-计算-更新></a> 读取 计算 更新</h1><p>在<code>CPU</code>中要对值做一个更新操作，需要经历读取值，计算值，更新值的过程，比如一个 <code>i = i + 5</code>底层会生成三条汇编指令：</p><pre class="line-numbers language-asm" data-language=asm><code class=language-asm>&#x2F;&#x2F; 读取：从内存读取地址i的值
MOV AX, iaddr
&#x2F;&#x2F; 计算：对寄存器中的值进行加 5 操作
ADD AX, 5    
&#x2F;&#x2F; 更新：将计算后的结果写回到内存中的 i
MOV iaddr, AX <span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果多个线程同时对<code>i</code>进行读写操作，那么最终的结果很有可能会与预期不一致</p><table><thead><tr><th>执行时序</th><th>线程</th><th>内存 i 地址存储的值</th><th>读取(AX = i)</th><th>AX 计算</th><th>更新(i = AX)</th><th>线程状态</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>10</td><td>10</td><td></td><td></td><td><code>RUNNING</code> (context switch)</td></tr><tr><td>2</td><td>B</td><td>10</td><td>10</td><td>AX = 20 = AX + 10</td><td>i = AX = 20</td><td><code>RUNNING</code></td></tr><tr><td>3</td><td>A</td><td>20</td><td>10</td><td>AX = 15 = AX + 5</td><td>i = AX = 15</td><td><code>RUNNING</code></td></tr><tr><td>4</td><td>A</td><td>15</td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>B</td><td>15</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>可以看到表格最后<code>i</code>的值为15，<code>B线程</code>所做的更新被<code>A线程</code>覆盖，与预期的20不一致，在<code>i</code>上发生了线程安全问题，为了保证计算与更新值的结果是正确的，一般通过两种途径：</p><ul><li>对关于<code>i</code>的临界区代码加锁，确保同一时刻只有一个线程能执行临界区中的代码</li><li>要么通过CAS指令来自旋更新，直到更新成功</li></ul><h1 id=cas指令><a class=markdownIt-Anchor href=#cas指令></a> CAS指令</h1><blockquote><p><code>CAS</code>的全称为：Compare And Swap，顾名思义就是比较目标地址的值是否与期望值相等，如果相等就把目标值更新到目标地址中</p></blockquote><p>在解析底层源码之前，先了解一下<code>cas</code>底层的指令<br>我们常用的<code>cpu</code>一般为两种架构，分别是<code>x86</code>和<code>arm</code>，这两种架构都有各自的指令集，指令集中都定义了各自的cas指令</p><ul><li><code>X86</code>：指令复杂，性能优秀，功耗较高，广泛用于PC，服务器等领域</li><li><code>ARM</code>：指令精简，保证一定性能的同时，功耗表现出色，广泛用于移动端中断，嵌入式设备等领域</li></ul><h2 id=x86><a class=markdownIt-Anchor href=#x86></a> X86</h2><blockquote><p>下文指令介绍来源于 Intel 开发人员手册 <a target=_blank rel=noopener href="https://www.intel.cn/content/www/cn/zh/content-details/782158/intel-64-and-ia-32-architectures-software-developer-s-manual-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html?wapkw=intel%2064%20and%20ia-32%20architectures%20software%20developer%27s%20manual&amp;docid=782158">Intel® 64 和 IA-32 架构软件开发人员手册合并卷：1、2A、2B、2C、2D、3A、3B、3C、3D 和 4</a></p></blockquote><p>在X86中，定义了指令<code>CMPXCHG</code>，它的基本功能是比较EAX寄存器的值和指定内存地址的值，如果相等，则将内存地址中的值替换为指定操作数的值，如果不相等，则将内存地址中的值加载到EAX寄存器中</p><ul><li><code>CMPXCHG</code>指令原型：<code>CMPXCHG address, new_value</code><ul><li>将比较值放入<code>EAX</code>寄存器的指令要先于<code>CMPXCHG</code>指令之前定义：<code>MOV EAX, expected_value</code></li></ul></li></ul><p>可以看到，<code>CMPXCHG</code> 指令将值的读取和比较更新分为了两步，先需要将目标地址的期望值放入<code>EAX</code>寄存器，再来执行<code>CMPXCHG</code>指令完成比较并交换的操作，因此只是保证了<strong>比较和更新</strong>操作的原子性，不能保证读取到的数据一定是最新的，所以会出现CAS失败的情况，因此上层需要通过自旋来执行CAS操作，确保能够完成更新。</p><p>我们通过<code>CMPXCHG</code>指令可以完成比较值和更新值的原子性，但如果只通过该指令就能完成原子操作了吗，显然没有这么简单，听我细细道来</p><h2 id=cpu-缓存><a class=markdownIt-Anchor href=#cpu-缓存></a> CPU 缓存</h2><blockquote><p>详细了解<code>CPU</code>缓存体系可移步这篇博客 <a href=/posts/1a5fbe08.html>CPU缓存与MESI协议</a></p><ul><li>下面的内容大部分来源于该博客</li></ul></blockquote><p><code>cpu</code>在将数据写入到目标地址之前，需要将数据先从内存读取到<code>L1数据缓存</code>，再从<code>L1数据缓存</code>读取到<code>寄存器</code>中，经过<code>ALU</code>计算，再通过<code>mov</code>系列指令把数据拷贝到目标地址，但此时只是写入<code>L1数据缓存</code>，而<code>L1数据缓存</code>它是<code>cpu</code>私有的，那么在多cpu环境下(<em>假设每个cpu只有一个核</em>)，如果没有额外的手段，就会造成<code>cpu A</code>对地址<code>A</code>的值的更新操作是对其他<code>cpu</code>是不可见的，因为此时最新的数据只是在它自己的<code>L1私有数据缓存</code>中，对于这个问题，聪明的<code>cpu</code>设计师当然给出了解决办法</p><h3 id=lock-指令><a class=markdownIt-Anchor href=#lock-指令></a> Lock# 指令</h3><blockquote><p>关于Intel 开发人员手册 对 Lock# 指令的介绍可以查阅下面的文章</p><ul><li>– 卷2 Chapter 3.3 LOCK—Assert LOCK# Signal Prefix 1213 页</li><li>– 卷3 Chapter 10.1 Locked Atomic Operations 3368页<br>下面的内容大部分来自于该手册</li></ul></blockquote><p>Intel 为<code>cpu</code>提供了 Lock# 指令，将该指令与特定指令结合使用可以保证多个<code>CPU</code>对目标共享地址的操作是互斥的，因为Lock 指令需要和其他指令结合使用因此也称为 <code>Lock 锁前缀</code></p><p>在早期的Intel cpu中(<em>如Pentium</em>)，Lock 锁前缀指令总是会通过总线仲裁器来锁定总线，保证了特定的指令在执行时是原子的以及多处理器环境下读写目标地址数据的一致性，防止其他<code>CPU</code>同时访问或修改同一内存地址的数据，但这种方式会导致其他Cpu在总线锁定的期间，因为处理器无法使用总线去访问内存而导致的阻塞(stall)，导致了性能的急剧降低，因此在<code>P6</code>以及后续Intel处理器中，增加了<code>缓存行锁定</code>技术来解决因总线锁定而导致的性能瓶颈</p><h4 id=总线仲裁器><a class=markdownIt-Anchor href=#总线仲裁器></a> 总线仲裁器</h4><p>在介绍下面的概念之前，我想先介绍一个重要的硬件单元<code>总线仲裁器</code>，总线仲裁器它连接了所有设备所访问的总线，包括地址总线，数据总线，控制总线，它管理多个设备对共享总线的访问请求，确保在同一时间只有一个设备能够访问总线，从而避免数据冲突和不一致性</p><ul><li><code>地址总线(Address Bus)</code>：用于指定数据传输的目标地址</li><li><code>数据总线(Data Bus)</code>：用于数据的传输</li><li><code>控制总线</code>：用于传输控制信号，如读写命令，中断请求等</li></ul><p>工作流程</p><ol><li>接受请求：接收来自各个设备(如cpu，dma控制器，i/o设备等)的总线访问请求</li><li>分配总线使用权：根据某种算法(如固定优先级，轮询等)决定哪个设备获得总线的使用权</li><li>释放总线使用权：当设备完成数据传输后，释放总线使用权，允许其他设备访问总线</li></ol><h4 id=总线锁定><a class=markdownIt-Anchor href=#总线锁定></a> 总线锁定</h4><p>介绍一下总线锁定的流程，以理解为什么能保证指令执行的原子性和读写数据的一致性，性能瓶颈发生的原因</p><ol><li>CPU在执行<code>lock</code> 前缀指令时，会使能总线锁定引脚(Lock#)，向总线仲裁器发送电信号，该信号伴随当前总线周期(如内存读/写操作)持续有效，直至操作完成</li><li>总线仲裁器检测到<code>Lock</code>信号，会冻结当前请求仲裁队列，暂停处理其他设备的总线请求，确保当前CPU的操作不受干扰，阻止其他设备抢占总线</li><li>在<code>Lock</code>有效期间，CPU完全独占总线可以安全的对共享内存执行读写操作</li><li>CPU完成<code>Lock</code>指令后，撤销<code>Lock</code>信号，总线仲裁器恢复正常工作，其他设备此时可以竞争访问总线</li></ol><p>可以看到整个流程，总线锁定需要一直等待<code>lock</code>指令的执行完成才能释放总线，在此期间，所有设备都无法访问总线，可想而知对性能的影响有多大</p><h4 id=缓存行锁定><a class=markdownIt-Anchor href=#缓存行锁定></a> 缓存行锁定</h4><blockquote><p>下面内容都来源下面这篇博客，此处为了该篇博客的完整性，提供对缓存行以及相关概念的简要说明，详细细节请看：</p><ul><li><a href=/posts/1a5fbe08.html>CPU缓存与MESI协议</a></li></ul></blockquote><h5 id=缓存结构><a class=markdownIt-Anchor href=#缓存结构></a> 缓存结构</h5><p>处理器在访问内存时通常需要100到300个周期，这意味着在这个访存周期中，cpu只能干等着内存控制器将数据响应给cpu，为了提高效率，弥补处理器与内存之间的差距，因此在处理器与内存之间增加了缓存结构，分为<code>L1</code>，<code>L2</code>，<code>L3</code>三级缓存，<code>L1缓存</code>和<code>L2缓存</code>是<code>cpu核心</code>私有，而<code>L3</code>缓存则属于同一个<code>cpu</code>的核心共享，越靠近cpu的速度也就越快，但是可存储的容量也越小</p><h5 id=缓存行状态><a class=markdownIt-Anchor href=#缓存行状态></a> 缓存行状态</h5><p>不管是L1，L2，L3缓存，其缓存行的状态都会在<code>Modified</code>,<code>Exclusive</code>,<code>Shared</code>,<code>Invalidate</code>四个状态中切换</p><ul><li><code>Modified</code>：当前缓存行中的副本数据已被修改，意味着内存中的数据是过期的</li><li><code>Exclusive</code>：处于该状态的缓存行表示只存在当前cpu的缓存中，并且与内存中的副本相同</li><li><code>Shared</code>：处于该状态的缓存行意味着同时也存在其他cpu的缓存中，并且与内存中的副本相同</li><li><code>Invalidate</code>：处于该状态的缓存行表示是失效状态无法访问，需要重新执行缓存行填充</li></ul><h5 id=内存目录><a class=markdownIt-Anchor href=#内存目录></a> 内存目录</h5><p>内存目录是多核处理器系统中用于高效管理缓存一致性的关键硬件结构，它通过记录内存块<sup class=footnote-ref><a href=#fn1 id=fnref1>[1]</a></sup>在各级缓存中的状态和位置，减少了传统<code>侦听</code>(<em>Snooping</em>)协议中的广播开销</p><ul><li>如果没有内存目录记录内存块的信息，那么根据传统<code>侦听协议</code>的处理，需要在总线上广播请求，缓存了该内存块的<code>cpu</code>收到请求后则给出响应，没有则访问主存</li></ul><blockquote><p>内存目录通常集成在内存控制器或者是L3缓存中</p></blockquote><p>内存目录的作用就是对缓存状态进行跟踪，它会记录每个内存块(缓存行)的缓存副本分布在哪些<code>cpu</code>中，以及在这些<code>cpu</code>缓存中的状态，通过精确的目录信息，避免向所有<code>cpu</code>广播请求，仅发送给持有有效状态缓存的<code>cpu</code>，减少了无效的总线侦听流量</p><h5 id=缓存状态的维护><a class=markdownIt-Anchor href=#缓存状态的维护></a> 缓存状态的维护</h5><p>缓存行的状态是由缓存一致性<code>MESI</code>协议维护，当某个<code>cpu</code>核心想要写入某个地址的数据时，必须要在L1缓存中持有该内存块的缓存行，并且缓存行状态必须为<code>E</code>或<code>M</code>的，如果是其他状态(<code>R</code>或者<code>I</code>)或者没有未在缓存行命中，那么就需要通过额外的方式来获取对该地址的可修改权力，如果有<code>cpu</code>，这是缓存一致性协议为了保证多核之间的缓存数据的一致性所规定的</p><h5 id=cpu-读取内存数据流程><a class=markdownIt-Anchor href=#cpu-读取内存数据流程></a> cpu 读取内存数据流程</h5><p>cpu在读取内存数据时，首先会检查最近的L1缓存，如果命中就直接返回，未命中则向下查询L2缓存，如果L2缓存命中，那么返回数据并写入L1缓存，未命中，继续查询L3缓存，如果命中，返回数据并写入L2缓存和L1缓存，如果未命中，那么会通过向内存控制器发送<code>BusRead</code>请求，内存控制器会检查内存目录，查看该地址的数据是否被其他cpu缓存，如果是，则在总线上广播请求，持有了该地址缓存行的<code>cpu</code>会响应数据，如果状态是M，根据<code>缓存一致性协议</code>，那么需要将缓存行的数据写入主存，并将状态修改为S，如果其他<code>cpu</code>的缓存中没有该地址的数据，则内存控制器需要访问主存，并通过预取技术读取包含该目标地址前后的64个字节，然后将数据按顺序从主存填充到L3，并且同时触发L2和L1的<code>级联填充</code>，数据写入各自的缓存</p><h5 id=cpu-写入内存数据流程><a class=markdownIt-Anchor href=#cpu-写入内存数据流程></a> cpu 写入内存数据流程</h5><p>cpu 将数据写入目标内存地址之前，首先会检查是否持有该目标内存地址的缓存行，如果持有，并且状态是<code>E</code>，那么直接写入，并且更改缓存行状态为<code>M</code>，</p><h3 id=arm><a class=markdownIt-Anchor href=#arm></a> ARM</h3><hr class=footnotes-sep><section class=footnotes><ol class=footnotes-list><li id=fn1 class=footnote-item><p>内存块通常对应一个缓存行 <a href=#fnref1 class=footnote-backref>↩︎</a></p></li></ol></section></article><div class=post-copyright><div class=post-copyright__author><span class=post-copyright-meta><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class=post-copyright-info><a href=https://juzzia.github.io>Juzzia</a></span></div><div class=post-copyright__type><span class=post-copyright-meta><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class=post-copyright-info><a href=https://juzzia.github.io/posts/6961ed95.html>https://juzzia.github.io/posts/6961ed95.html</a></span></div><div class=post-copyright__notice><span class=post-copyright-meta><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class=post-copyright-info>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href=https://juzzia.github.io target=_blank>Juzzia's Blog</a>！</span></div></div><div class=tag_share><div class=post-meta__tag-list><a class=post-meta__tags href=/tags/%E6%BA%90%E7%A0%81/ >源码</a><a class=post-meta__tags href=/tags/JVM/ >JVM</a></div><div class=post_share><div class=social-share data-image=/img/avatar.jpg data-sites=wechat,weibo,qq></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css media=print onload='this.media="all"'><script src=https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js defer=defer></script></div></div><div class=post-reward><div class=reward-button><i class="fas fa-qrcode"></i>赞助</div><div class=reward-main><ul class=reward-all><li class=reward-item><a href=https://s2.loli.net/2024/08/01/jL2klE39vx5Ft4r.jpg target=_blank><img class=post-qr-code-img src=https://s2.loli.net/2024/08/01/jL2klE39vx5Ft4r.jpg alt=wechat></a><div class=post-qr-code-desc>wechat</div></li><li class=reward-item><a href=https://s2.loli.net/2024/08/01/2s3UCWdlneAiYRa.jpg target=_blank><img class=post-qr-code-img src=https://s2.loli.net/2024/08/01/2s3UCWdlneAiYRa.jpg alt=alipay></a><div class=post-qr-code-desc>alipay</div></li></ul></div></div><nav class=pagination-post id=pagination><div class="prev-post pull-left"><a href=/posts/cff6dd61.html title=JMM><div class=cover style=background:var(--default-bg-color)></div><div class=pagination-info><div class=label>上一篇</div><div class=prev_info>JMM</div></div></a></div><div class="next-post pull-right"><a href=/posts/7e818be6.html title=记录一次排查因线程WAITING导致应用假死的经历><div class=cover style=background:var(--default-bg-color)></div><div class=pagination-info><div class=label>下一篇</div><div class=next_info>记录一次排查因线程WAITING导致应用假死的经历</div></div></a></div></nav><div class=relatedPosts><div class=headline><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class=relatedPosts-list><div><a href=/posts/1fe4afce.html title="字节码指令执行过程 BytecodeInterpreter"><div class=cover style=background:var(--default-bg-color)></div><div class="content is-center"><div class=date><i class="far fa-calendar-alt fa-fw"></i> 2025-03-07</div><div class=title>字节码指令执行过程 BytecodeInterpreter</div></div></a></div><div><a href=/posts/f95e72b6.html title="字节码解释器 Interpreter"><div class=cover style=background:var(--default-bg-color)></div><div class="content is-center"><div class=date><i class="far fa-calendar-alt fa-fw"></i> 2025-02-18</div><div class=title>字节码解释器 Interpreter</div></div></a></div></div></div><hr class=custom-hr><div id=post-comment><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class=comment-wrap><div><div id=giscus-wrap></div></div></div></div></div><div class=aside-content id=aside-content><div class="card-widget card-info"><div class=is-center><div class=avatar-img><img src=/img/avatar.jpg onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt=avatar></div><div class=author-info__name>Juzzia</div><div class=author-info__description>分享技术，开发经验，学习总结</div></div><div class="card-info-data site-data is-center"><a href=/archives/ ><div class=headline>文章</div><div class=length-num>10</div></a><a href=/tags/ ><div class=headline>标签</div><div class=length-num>4</div></a><a href=/categories/ ><div class=headline>分类</div><div class=length-num>5</div></a></div><a id=card-info-btn target=_blank rel=noopener href=https://github.com/juzzia><i class="fab fa-github"></i><span>github</span></a><div class="card-info-social-icons is-center"><a class=social-icon href=https://github.com/juzzia target=_blank title=Github><i class="fab fa-github" style=color:#24292e></i></a><a class=social-icon href=mailto:juzzia@github.com target=_blank title=Email><i class="fas fa-envelope" style=color:#4a7dbe></i></a></div></div><div class=sticky_layout><div class=card-widget id=card-toc><div class=item-headline><i class="fas fa-stream"></i><span>目录</span><span class=toc-percentage></span></div><div class="toc-content is-expand"><ol class=toc><li class="toc-item toc-level-1"><a class=toc-link href=#%E5%BC%95%E8%A8%80><span class=toc-number>1.</span> <span class=toc-text>引言</span></a></li><li class="toc-item toc-level-1"><a class=toc-link href=#atomiclong><span class=toc-number>2.</span> <span class=toc-text>AtomicLong</span></a></li><li class="toc-item toc-level-1"><a class=toc-link href=#%E8%AF%BB%E5%8F%96-%E8%AE%A1%E7%AE%97-%E6%9B%B4%E6%96%B0><span class=toc-number>3.</span> <span class=toc-text>读取 计算 更新</span></a></li><li class="toc-item toc-level-1"><a class=toc-link href=#cas%E6%8C%87%E4%BB%A4><span class=toc-number>4.</span> <span class=toc-text>CAS指令</span></a><ol class=toc-child><li class="toc-item toc-level-2"><a class=toc-link href=#x86><span class=toc-number>4.1.</span> <span class=toc-text>X86</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#cpu-%E7%BC%93%E5%AD%98><span class=toc-number>4.2.</span> <span class=toc-text>CPU 缓存</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#lock-%E6%8C%87%E4%BB%A4><span class=toc-number>4.2.1.</span> <span class=toc-text>Lock# 指令</span></a><ol class=toc-child><li class="toc-item toc-level-4"><a class=toc-link href=#%E6%80%BB%E7%BA%BF%E4%BB%B2%E8%A3%81%E5%99%A8><span class=toc-number>4.2.1.1.</span> <span class=toc-text>总线仲裁器</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E6%80%BB%E7%BA%BF%E9%94%81%E5%AE%9A><span class=toc-number>4.2.1.2.</span> <span class=toc-text>总线锁定</span></a></li><li class="toc-item toc-level-4"><a class=toc-link href=#%E7%BC%93%E5%AD%98%E8%A1%8C%E9%94%81%E5%AE%9A><span class=toc-number>4.2.1.3.</span> <span class=toc-text>缓存行锁定</span></a><ol class=toc-child><li class="toc-item toc-level-5"><a class=toc-link href=#%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84><span class=toc-number>4.2.1.3.1.</span> <span class=toc-text>缓存结构</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E7%BC%93%E5%AD%98%E8%A1%8C%E7%8A%B6%E6%80%81><span class=toc-number>4.2.1.3.2.</span> <span class=toc-text>缓存行状态</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E5%86%85%E5%AD%98%E7%9B%AE%E5%BD%95><span class=toc-number>4.2.1.3.3.</span> <span class=toc-text>内存目录</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#%E7%BC%93%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E7%BB%B4%E6%8A%A4><span class=toc-number>4.2.1.3.4.</span> <span class=toc-text>缓存状态的维护</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#cpu-%E8%AF%BB%E5%8F%96%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B><span class=toc-number>4.2.1.3.5.</span> <span class=toc-text>cpu 读取内存数据流程</span></a></li><li class="toc-item toc-level-5"><a class=toc-link href=#cpu-%E5%86%99%E5%85%A5%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B><span class=toc-number>4.2.1.3.6.</span> <span class=toc-text>cpu 写入内存数据流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class=toc-link href=#arm><span class=toc-number>4.2.2.</span> <span class=toc-text>ARM</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class=item-headline><i class="fas fa-history"></i><span>最新文章</span></div><div class=aside-list><div class="aside-list-item no-cover"><div class=content><a class=title href=/posts/1fe4afce.html title="字节码指令执行过程 BytecodeInterpreter">字节码指令执行过程 BytecodeInterpreter</a><time datetime=2025-03-07T13:34:00.000Z title="发表于 2025-03-07 21:34:00">2025-03-07</time></div></div><div class="aside-list-item no-cover"><div class=content><a class=title href=/posts/1a5fbe08.html title=CPU缓存与MESI协议>CPU缓存与MESI协议</a><time datetime=2025-03-04T12:42:00.000Z title="发表于 2025-03-04 20:42:00">2025-03-04</time></div></div><div class="aside-list-item no-cover"><div class=content><a class=title href=/posts/bcc098b4.html title="Liunx 任务调度">Liunx 任务调度</a><time datetime=2025-02-24T13:52:00.000Z title="发表于 2025-02-24 21:52:00">2025-02-24</time></div></div><div class="aside-list-item no-cover"><div class=content><a class=title href=/posts/991d833e.html title="Liunx Futex">Liunx Futex</a><time datetime=2025-02-22T15:33:00.000Z title="发表于 2025-02-22 23:33:00">2025-02-22</time></div></div><div class="aside-list-item no-cover"><div class=content><a class=title href=/posts/f95e72b6.html title="字节码解释器 Interpreter">字节码解释器 Interpreter</a><time datetime=2025-02-18T14:45:00.000Z title="发表于 2025-02-18 22:45:00">2025-02-18</time></div></div></div></div></div></div></main></div><div id=rightside><div id=rightside-config-hide><button id=readmode type=button title=阅读模式><i class="fas fa-book-open"></i></button><button id=darkmode type=button title=浅色和深色模式转换><i class="fas fa-adjust"></i></button><button id=hide-aside-btn type=button title=单栏和双栏切换><i class="fas fa-arrows-alt-h"></i></button></div><div id=rightside-config-show><button id=rightside-config type=button title=设置><i class="fas fa-cog fa-spin"></i></button><button class=close id=mobile-toc-button type=button title=目录><i class="fas fa-list-ul"></i></button><a id=to_comment href=#post-comment title=直达评论><i class="fas fa-comments"></i></a><button id=go-up type=button title=回到顶部><span class=scroll-percent></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class=js-pjax><script>(()=>{var e=()=>{var e;0!==(e=document.querySelectorAll("pre > code.mermaid")).length&&e.forEach(e=>{var t=document.createElement("div");t.className="mermaid-wrap",t.innerHTML=`<pre class="mermaid-src" hidden>${e.textContent}</pre>`,e.parentNode.replaceWith(t)});let t=document.querySelectorAll("#article-container .mermaid");0!==t.length&&(e=()=>(e=>{window.loadMermaid=!0;let c="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach((e,t)=>{let n=e.firstElementChild;e="%%{init:{ 'theme':'"+c+"'}}%%\n"+n.textContent;let i=mermaid.render("mermaid-"+t,e);"string"==typeof i?(t=i,n.insertAdjacentHTML("afterend",t)):(i.then(({svg:e})=>{n.insertAdjacentHTML("afterend",e)}),setTimeout(()=>{var e=document.getElementsByTagName("svg");Array.from(e).forEach((e,t)=>{o(e)})},3e3))})})(t),btf.addGlobalFn("themeChange",e,"mermaid"),window.loadMermaid?e():btf.getScript("https://cdn.jsdelivr.net/npm/mermaid@11.0.0/dist/mermaid.min.js").then(e))};let o=l=>{let u=1,m=0,h=0,c=!1,o,d,r=0,e=!1,t=1,n=0,i=0;function a(){u=t,m=n,h=i,e=!1,s()}function s(){l.style.transform=`translate(${m}px, ${h}px) scale(${u})`}l.addEventListener("wheel",function(e){e.preventDefault();var t=0<e.deltaY?-.04:.04,n=(t=Math.min(Math.max(u+t,1),2.3))/u,i=l.getBoundingClientRect(),c=(e.clientX-i.left)/i.width,e=(e.clientY-i.top)/i.height,i=l.getBBox(),c=c*i.width,e=e*i.height;m=m*n-c*(n-1),h=h*n-e*(n-1),u=t,s()}),l.addEventListener("mousedown",function(e){c=!0,o=e.clientX,d=e.clientY,l.style.cursor="grabbing"}),document.addEventListener("mousemove",function(e){c&&(m+=e.clientX-o,h+=e.clientY-d,o=e.clientX,d=e.clientY,s())}),document.addEventListener("mouseup",function(){c=!1,l.style.cursor="grab"}),l.parentElement.addEventListener("dblclick",function(e){var t=Date.now();a(),r=t}),l.addEventListener("touchstart",function(e){if(1===e.touches.length&&((t=Date.now())-r<300&&(n=Date.now(),a(),r=n),r=t),1===(n=e).touches.length)c=!0,o=n.touches[0].clientX,d=n.touches[0].clientY;else if(2===n.touches.length){var t=n.touches[0].clientX-n.touches[1].clientX,n=n.touches[0].clientY-n.touches[1].clientY;let o=Math.sqrt(t*t+n*n),d=m,r=h,a=u;function i(e){var t,n,i,c;2===e.touches.length&&(t=e.touches[0].clientX-e.touches[1].clientX,n=e.touches[0].clientY-e.touches[1].clientY,t=Math.sqrt(t*t+n*n)/o,n=Math.min(Math.max(a*t,.5),1.15),c=(e.touches[0].clientX+e.touches[1].clientX)/2-l.getBoundingClientRect().left,e=(e.touches[0].clientY+e.touches[1].clientY)/2-l.getBoundingClientRect().top,i=l.getBBox(),c=c/l.getBoundingClientRect().width*i.width,e=e/l.getBoundingClientRect().height*i.height,m=d*t-c*(t-1),h=r*t-e*(t-1),u=n,s())}document.addEventListener("touchmove",i),document.addEventListener("touchend",function e(){document.removeEventListener("touchmove",i),document.removeEventListener("touchend",e)})}}),document.addEventListener("touchend",function(){c=!1})};btf.addGlobalFn("encrypt",e,"mermaid"),window.pjax?e():document.addEventListener("DOMContentLoaded",e)})()</script><script>(()=>{let s=t=>"dark"===t?"dark":"light";var t=()=>{var t,e=Object.assign({src:"https://giscus.app/client.js","data-repo":"juzzia/blog-comment","data-repo-id":"R_kgDOMc3hsw","data-category-id":"DIC_kwDOMc3hs84ChTYG","data-mapping":"pathname","data-theme":s(document.documentElement.getAttribute("data-theme")),"data-reactions-enabled":"1",crossorigin:"anonymous",async:!0},{"data-input-position":"top","data-emit-metadata":1,"data-lang":"zh-CN"}),a=document.createElement("script");for(t in e)a.setAttribute(t,e[t]);document.getElementById("giscus-wrap").appendChild(a)};function e(t){var e=document.querySelector("#post-meta .gsc-comments-count");e&&(e.textContent=t)}window.addEventListener("message",function(t){"https://giscus.app"===t.origin&&"object"==typeof t.data&&t.data.giscus&&((t=t.data.giscus).error?e(0):t.discussion&&e(t.discussion.totalCommentCount+t.discussion.totalReplyCount))}),btf.addGlobalFn("themeChange",t=>{var e;t={setConfig:{theme:s(t)}},(e=document.querySelector("iframe.giscus-frame"))&&e.contentWindow.postMessage({giscus:t},"https://giscus.app")},"giscus"),t()})()</script></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css media=print onload='this.media="all"'><script src=https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js></script><script src=https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js></script><script async data-pjax src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><div id=local-search><div class=search-dialog><nav class=search-nav><span class=search-dialog-title>搜索</span><span id=loading-status></span><button class=search-close-button><i class="fas fa-times"></i></button></nav><div class=is-center id=loading-database><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class=search-wrap><div id=local-search-input><div class=local-search-box><input class=local-search-box--input placeholder=搜索文章 type=text></div></div><hr><div id=local-search-results></div><div id=local-search-stats-wrap></div></div></div><div id=search-mask></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>